<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Match Words Game</title>
    <style>
        .container {
            display: flex;
            justify-content: center;
            margin: 10px;
        }
        .column {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .box {
            border: 1px solid #000;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 10px;
            cursor: pointer;
            transition: background-color 0.3s;
            max-width: 200px;
            word-wrap: break-word;
            overflow-wrap: break-word;
            white-space: normal;
            width: 100%; /* Ensures boxes are the same width */
        }
        .matched {
            background-color: green;
        }
        .incorrect {
            background-color: red;
            animation: flash 0.5s;
        }
        .selected {
            background-color: lightgray;
        }
        @keyframes flash {
            0% { background-color: red; }
            100% { background-color: white; }
        }
    </style>
</head>
<body>
<div class="container">
    <div class="column" id="wordsContainer">
        <div class="box" id="word-1"></div>
        <div class="box" id="word-2"></div>
        <div class="box" id="word-3"></div>
        <div class="box" id="word-4"></div>
    </div>
    <div class="column" id="explanationsContainer">
        <div class="box" id="explanation-1"></div>
        <div class="box" id="explanation-2"></div>
        <div class="box" id="explanation-3"></div>
        <div class="box" id="explanation-4"></div>
    </div>
</div>
    <script>
        const task = JSON.parse(sessionStorage.getItem('task_content'));
        const data = [
            { word: task.word1, explanation: task.explanation1},
            { word: task.word2, explanation: task.explanation2},
            { word: task.word3, explanation: task.explanation3},
            { word: task.word4, explanation: task.explanation4}
        ];

        const wordsContainer = document.getElementById('wordsContainer');
        const explanationsContainer = document.getElementById('explanationsContainer');

        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        shuffle(data);
        const explanations = [...data];
        shuffle(explanations);

        data.forEach((item, index) => {
            const div = document.getElementById(`word-${index + 1}`);
            div.innerHTML = `<span style="font-size: larger; font-weight: bold;">${item.word}</span>`;
            div.onclick = () => handleWordClick(div, item);

            const divExplanation = document.getElementById(`explanation-${index + 1}`);
            divExplanation.textContent = item.explanation;
            divExplanation.onclick = () => handleExplanationClick(item);
        });

        let selectedWord = null;

        function handleWordClick(box, wordItem) {
            if (selectedWord) {
                selectedWord.box.classList.remove('selected');
            }
            selectedWord = { item: wordItem, box: box };
            box.classList.add('selected');
        }

        function reorderAfterMatch() {
            const matched = [...wordsContainer.children].filter(box => box.classList.contains('matched'));
            const nonMatched = [...wordsContainer.children].filter(box => !box.classList.contains('matched'));
            const explanationsMatched = [...explanationsContainer.children].filter(box => box.classList.contains('matched'));
            const explanationsNonMatched = [...explanationsContainer.children].filter(box => !box.classList.contains('matched'));

            matched.forEach(box => wordsContainer.appendChild(box));
            nonMatched.forEach(box => wordsContainer.appendChild(box));
            explanationsMatched.forEach(box => explanationsContainer.appendChild(box));
            explanationsNonMatched.forEach(box => explanationsContainer.appendChild(box));
        }

        function handleExplanationClick(explanationItem) {
            if (selectedWord) {
                if (selectedWord.item.explanation === explanationItem.explanation) {
                    selectedWord.box.classList.add('matched');
                    const index = [...explanationsContainer.children].findIndex(box => box.textContent === explanationItem.explanation);
                    explanationsContainer.children[index].classList.add('matched');
                    setTimeout(() => {
                        wordsContainer.appendChild(selectedWord.box);
                        explanationsContainer.appendChild(explanationsContainer.children[index]);
                        reorderSquares();
                    }, 500);
                    reorderAfterMatch();
                } else {
                    const explanationBox = [...explanationsContainer.children].find(box => box.textContent === explanationItem.explanation);
                    explanationBox.classList.add('incorrect');
                    setTimeout(() => {
                        explanationBox.classList.remove('incorrect');
                    }, 1000);
                }
                selectedWord.box.classList.remove('selected');
                selectedWord = null;
            }
        }

        function reorderSquares() {
            const words = [...wordsContainer.children].sort(() => Math.random() - 0.5);
            const explanations = [...explanationsContainer.children].sort(() => Math.random() - 0.5);

            words.forEach(box => wordsContainer.appendChild(box));
            explanations.forEach(box => explanationsContainer.appendChild(box));
        }
    </script>
</body>
</html>